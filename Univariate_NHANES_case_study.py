# -*- coding: utf-8 -*-
"""2nd_Univariate data analyses - NHANES case study_REMAKE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/198UQP8NtEyq1VldTLammU5_MMNH6Ofwy

## PRACTICE NOTEBOOK
"""

import pandas as pd
import seaborn as sns
import statsmodels.api as sm
import numpy as np
import plotly.express as px
import matplotlib as mtp

data = pd.read_csv("NHANES.csv")
pd.set_option("display.max_columns", 100)
data.head()

data["RIDAGEYR"].describe()

data['RIAGENDR_str'] = data['RIAGENDR'].replace({1:'Male', 2:'Female'}) # asignamos texto a las variables de genero
data['RIAGENDR_str']
data["RIAGENDR_str"].astype(str)

"""# Question 1
Relabel the marital status variable DMDMARTL to have brief but informative character labels. Then construct a frequency table of these values for all people, then for women only, and for men only. Then construct these three frequency tables using only people whose age is between 30 and 40.
"""

# cambiando los valores numéricos por el texto que les equivale en la columa Marital Status
data["DMDMARTL_str"] = data.DMDMARTL.replace({1: "Married", 2: "Widowed", 3: "Divorced", 4: "Separated", 5: "Never Married", 6: "living with Partner", 77: "Refused", 99: "Don´t Know"})
# Frequency table of all data
data.DMDMARTL_str.value_counts()

# Frequency Table for women

# Create Women only subdata
data_subFem = data.query("RIAGENDR == 2") # value 2 corresponds to women
data_subFem.iloc[:5,:10] # one way to probe the existance of the new sub data
data_subFem.head() # another way to prove the existance of new sub data

# Create Frenquency table of sub data women
# Option 1, without using the sub data, but directly from the whole dataset
data.query("RIAGENDR == 2")["DMDMARTL_str"].value_counts()

# Option 2, using subdata
data_subFem["DMDMARTL_str"].value_counts()

# Frequency Table for men

# Create Men only wubdata
data_subMen = data.query("RIAGENDR == 1") # value 1 corresponds to men
data_subMen.head() # one of the ways to prove the existane of the new sub data

# Create Frenquency table of sub data men
# Option 1
data.query("RIAGENDR == 1")["DMDMARTL_str"].value_counts() # one way without creating sub data

#Option 2
data_subMen["DMDMARTL_str"].value_counts() # another way to get frequency table using sub data

# Frequency Table all people between 30 and 40

# Create new sub data 30-40 years old
data_sub30_40 = data.query("RIDAGEYR >= 30 and RIDAGEYR <= 40")
data_sub30_40.head() # one of the ways to prove the existance of the new sub data with only ages between 30 and 40

# Create Frequency table for sub data ages 30-40
# Option 1, no sub data
data.query("RIDAGEYR >= 30 and RIDAGEYR <= 40")["DMDMARTL_str"].value_counts()

# Option 2, with sub data
data_sub30_40["DMDMARTL_str"].value_counts()

# Marital Status for women in their 30-40
data.query("RIAGENDR == 2 and RIDAGEYR >=30 and RIDAGEYR<=40")["DMDMARTL_str"].value_counts()

# Marital Status for men in their 30-40
data.query("RIAGENDR == 1 and RIDAGEYR >=30 and RIDAGEYR<=40")["DMDMARTL_str"].value_counts()

"""# Question 2
Restricting to the female population, stratify the subjects into age bands no wider than ten years, and construct the distribution of marital status within each age band. Within each age band, present the distribution in terms of proportions that must sum to 1.
"""

# Creating age strata
data_subFem["agegrp"] = pd.cut(data_subFem.RIDAGEYR, [17, 30, 40, 50, 60, 70, 80])

# Converting age strata to string
data_subFem["agegrp"].astype(str)

# Creating age strata
data_subMen["agegrp"] = pd.cut(data_subMen.RIDAGEYR, [17, 30, 40, 50, 60, 70, 80])

# Converting age strata to string
data_subMen["agegrp"].astype(str)

data_subFem.groupby("agegrp")["DMDMARTL_str"].value_counts()

# Debemos crear la nueva columna con valor texto en la sub data base de solo mujeres y también cambiar el data type
data_subFem["DMDMARTL_str"] = data_subFem.DMDMARTL.replace({1: "Married", 2: "Widowed", 3: "Divorced", 4: "Separated", 5: "Never Married", 6: "living with Partner", 77: "Refused", 99: "Don´t Know"})
data_subFem["DMDMARTL_str"].astype(str)

data_subMen["DMDMARTL_str"] = data_subMen.DMDMARTL.replace({1: "Married", 2: "Widowed", 3: "Divorced", 4: "Separated", 5: "Never Married", 6: "living with Partner", 77: "Refused", 99: "Don´t Know"})
data_subMen["DMDMARTL_str"].astype(str)

# igual con la de género
data_subFem['RIAGENDR_str'] = data_subFem['RIAGENDR'].replace({1:'Male', 2:'Female'}) # asignamos texto a las variables de genero
data_subFem["RIAGENDR_str"].astype(str)

data_subMen['RIAGENDR_str'] = data_subMen['RIAGENDR'].replace({1:'Male', 2:'Female'}) # asignamos texto a las variables de genero
data_subMen["RIAGENDR_str"].astype(str)

# it will run correctly if all columns stated below exist in the sub data base of data_subFem and the data type is the correct one for those needed to be strings
x = data_subFem.groupby(["agegrp", "RIAGENDR_str"])["DMDMARTL_str"]

x = x.value_counts()
x = x.unstack() # to restructure the results from long to wide
x = x.apply(lambda x: x/x.sum(), axis=1) # to normalize within each
print(x.to_string(float_format="%.3f")) # to limit isplay to 3 decimal places

"""# Question 3
Construct a histogram of the distribution of heights using the BMXHT variable in the NHANES sample.
"""

# with seaborn
sns.displot(data.BMXHT.dropna(), bins = 30)

# with plotly
px.histogram(data.BMXHT.dropna(), nbins = 30)

"""Make separate histograms for the heights of women and men, then make a side-by-side boxplot showing the heights of women and men."""

# height in women
# with seaborn
sns.displot(data_subFem.BMXHT.dropna())

# height in women
# with plotly
px.histogram(data_subFem.BMXHT.dropna())

# height in men
# with seaborn
sns.displot(data_subMen.BMXHT.dropna())

# height in men
# with plotly
px.histogram(data_subMen.BMXHT.dropna())

# side-by-side boxplot showing the heights of women and men.
# with seaborn
sns.boxplot(x="RIAGENDR_str", y="BMXHT", data=data)

# side-by-side boxplot showing the heights of women and men.
# with plotly
px.box(data, x="RIAGENDR_str", y="BMXHT", color="RIAGENDR_str")

"""# Question 4
Make a boxplot showing the distribution of within-subject differences between the first and second systolic blood pressure measurents (BPXSY1 and BPXSY2).
"""

# new column with differences between BPXSY1 - BPXSY2 for all sample size
data["BPXSY_Diff"] = data["BPXSY1"] - data["BPXSY2"]

# to make sure the new column was correctly created
data

# boxplot of the value of the new column difference between BPXSY1-BPXSY2
# with seaborn
sns.boxplot(x="BPXSY_Diff", data=data)

# boxplot of the value of the new column difference between BPXSY1-BPXSY2
# with plotly
px.box(data, x="BPXSY_Diff")

"""Make side-by-side boxplots of the two systolic blood pressure variables."""

# with seaborn
sns.boxplot(data=data.loc[:, ["BPXSY1", "BPXSY2"]]).set_ylabel("Blood Pressure in mm/Hg")

# with plotly
x1 = data.BPXSY1.dropna()
x2 = data.BPXSY2.dropna()
graph = px.box(data.loc[:, ["BPXSY1", "BPXSY2"]])#, color="x1") # no puedo poner diferente color por los na y "" que hay en ambas columnas
graph.update_layout(yaxis_title="Blood Pressure in mm/Hg")

# null values in both columns, problem with trying to change color in plotly in the graph from above
x = pd.isnull(data.BPXSY1).sum()
y = pd.isnull(data.BPXSY2).sum()
x, y

"""# Question 5
Construct a frequency table of household sizes for people within each educational attainment category (the relevant variable is DMDEDUC2). Convert the frequencies to proportions.
"""

data["DMDEDUC2_str"] = data.DMDEDUC2.replace({1: "<9", 2: "9-11", 3: "HS/GED", 4: "Some college/AA", 5: "College", 
                                       7: "Refused", 9: "Don't know"})
data["DMDEDUC2_str"].astype(str)

x = data.groupby("DMDHHSIZ")["DMDEDUC2_str"].value_counts()
x

y = data.groupby(["DMDEDUC2_str"])["DMDHHSIZ"].value_counts()
y

# in proportions
dy_total = data.groupby(["DMDEDUC2_str"])["DMDHHSIZ"].count()
y / dy_total

"""Restrict the sample to people between 30 and 40 years of age. Then calculate the median household size for women and men within each level of educational attainment."""

data_subFem["DMDEDUC2_str"] = data_subFem.DMDEDUC2.replace({1: "<9", 2: "9-11", 3: "HS/GED", 4: "Some college/AA", 5: "College", 
                                       7: "Refused", 9: "Don't know"})
data_subFem["DMDEDUC2_str"].astype(str)


data_subMen["DMDEDUC2_str"] = data_subMen.DMDEDUC2.replace({1: "<9", 2: "9-11", 3: "HS/GED", 4: "Some college/AA", 5: "College", 
                                       7: "Refused", 9: "Don't know"})
data_subMen["DMDEDUC2_str"].astype(str)

data_sub30_40["DMDEDUC2_str"] = data_sub30_40.DMDEDUC2.replace({1: "<9", 2: "9-11", 3: "HS/GED", 4: "Some college/AA", 5: "College", 
                                       7: "Refused", 9: "Don't know"})
data_sub30_40["DMDEDUC2_str"].astype(str)

y = data_sub30_40.groupby(["DMDEDUC2_str"])["DMDHHSIZ"].value_counts()
y

"""Then calculate the median household size for women and men within each level of educational attainment."""

# median for women
data_subFem["DMDHHSIZ"].median() # median for all women in the sample

# median for women for each level of education
w = data_subFem.groupby("DMDEDUC2_str")["DMDHHSIZ"].median()
w

# median for men
data_subMen["DMDHHSIZ"].median()

z = data_subMen.groupby("DMDEDUC2_str")["DMDHHSIZ"].median()
z

"""# Question 6
The participants can be clustered into "maked variance units" (MVU) based on every combination of the variables SDMVSTRA and SDMVPSU. Calculate the mean age (RIDAGEYR), height (BMXHT), and BMI (BMXBMI) for each gender (RIAGENDR), within each MVU, and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
"""

# age and females ON SDMVSTRA
a1 = data_subFem.groupby("SDMVSTRA")["RIDAGEYR"].mean()
a1

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(a1) - min(a1)

# age and males ON SDMVSTRA
a2 = data_subMen.groupby("SDMVSTRA")["RIDAGEYR"].mean()
a2

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(a2) - min(a2)

# height and females ON SDMVSTRA
a3 = data_subFem.groupby("SDMVSTRA")["BMXHT"].mean()
a3

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(a3) - min(a3)

# height and male ON SDMVSTRA
a4 = data_subMen.groupby("SDMVSTRA")["BMXHT"].mean()
a4

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(a4) - min(a4)

# BMI and females ON SDMVSTRA
a5 = data_subFem.groupby("SDMVSTRA")["BMXBMI"].mean()
a5

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(a5) - min(a5)

# BMI and male ON SDMVSTRA
a6 = data_subMen.groupby("SDMVSTRA")["BMXBMI"].mean()
a6

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(a6) - min(a6)

# age and females ON SDMVPSU
b1 = data_subFem.groupby("SDMVPSU")["RIDAGEYR"].mean()
b1

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(b1) - min(b1)

# age and male ON SDMVPSU
b2 = data_subMen.groupby("SDMVPSU")["RIDAGEYR"].mean()
b2

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(b2) - min(b2)

# height and females ON SDMVPSU
b3 = data_subFem.groupby("SDMVPSU")["BMXHT"].mean()
b3

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(b3) - min(b3)

# height and male ON SDMVPSU
b4 = data_subMen.groupby("SDMVPSU")["BMXHT"].mean()
b4

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(b4) - min(b4)

# BMI and females ON SDMVPSU
b5 = data_subFem.groupby("SDMVPSU")["BMXBMI"].mean()
b5

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(b5) - min(b5)

# BMI and male ON SDMVPSU
b6 = data_subMen.groupby("SDMVPSU")["BMXBMI"].mean()
b6

# and report the ratio between the largest and smallest mean (e.g. for height) across the MVUs.
max(b6) - min(b6)

"""Calculate the inter-quartile range (IQR) for age, height, and BMI for each gender and each MVU. Report the ratio between the largest and smalles IQR across the MVUs.

"""

# Inter-quartile range (IQR) for age, FEMALE on SDMVSTRA
a1_1 = np.percentile(a1, 75) - np.percentile(a1, 25)
a1_1

# Inter-quartile range (IQR) for age, MALE on SDMVSTRA
a2_2 = np.percentile(a2, 75) - np.percentile(a2, 25)
a2_2

# Inter-quartile range (IQR) for HEIGHT, FEMALE on SDMVSTRA
a3_3 = np.percentile(a3, 75) - np.percentile(a3, 25)
a3_3

# Inter-quartile range (IQR) for HEIGHT, MALE on SDMVSTRA
a4_4 = np.percentile(a4, 75) - np.percentile(a4, 25)
a4_4

# Inter-quartile range (IQR) for BMI, FEMALE on SDMVSTRA
a5_5 = np.percentile(a5, 75) - np.percentile(a5, 25)
a5_5

# Inter-quartile range (IQR) for BMI, MALE on SDMVSTRA
a6_6 = np.percentile(a6, 75) - np.percentile(a6, 25)
a6_6

# Inter-quartile range (IQR) for AGE, FEMALE on SDMVPSU
b1_1 = np.percentile(b1, 75) - np.percentile(b1, 25)
b1_1

# Inter-quartile range (IQR) for AGE, MALE on SDMVPSU
b2_2 = np.percentile(b2, 75) - np.percentile(b2, 25)
b2_2

# Inter-quartile range (IQR) for HEIGHT, FEMALE on SDMVPSU
b3_3 = np.percentile(b3, 75) - np.percentile(b3, 25)
b3_3

# Inter-quartile range (IQR) for HEIGHT, MALE on SDMVPSU
b4_4 = np.percentile(b4, 75) - np.percentile(b4, 25)
b4_4

# Inter-quartile range (IQR) for BMI, FEMALE on SDMVPSU
b5_5 = np.percentile(b5, 75) - np.percentile(b5, 25)
b5_5

# Inter-quartile range (IQR) for BMI, MALE on SDMVPSU
b6_6 = np.percentile(b6, 75) - np.percentile(b6, 25)
b6_6

# Comparing means on both stratas: SDMVSTRA, SDMVPSU
# age, female
a1_1, b1_1

# Comparing means on both stratas: SDMVSTRA, SDMVPSU
# age, male
a2_2, b2_2

# Comparing means on both stratas: SDMVSTRA, SDMVPSU
# height, female
a3_3, b3_3

# Comparing means on both stratas: SDMVSTRA, SDMVPSU
# height, male
a4_4, b4_4

# Comparing means on both stratas: SDMVSTRA, SDMVPSU
# bmi, female
a5_5, b5_5

# Comparing means on both stratas: SDMVSTRA, SDMVPSU
# bmi, male
a6_6, b6_6